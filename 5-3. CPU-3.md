### CPU3
- 명령어 세트
  - 구성요소
    - 연산코드 : 실제 수행될 연산(Load, Add 등 100개~200개 수준)
    - 오퍼랜드 : 연산을 수행하는 데 필요한 데이터 혹은 데이터 주소
      - 각 연산은 한 개 혹은 두 개의 입력 오퍼랜드와 한 개의 결과 오퍼랜드를 포함한다.
    - 다음 명령어 주소 : 오퍼랜드의 한 종류로 볼 수 있다.
      - 현재의 명령어 실행이 완료 후 다음 명령어를 인출할 위치 지정
      - 분기 혹은 호출 명령어와 같이 실행 순서 변경시 필요
  - 명령어 형식
    - 필드 : 명령어의 각 구성 요소에 소요되는 비트(연산코드, 오퍼랜드)
      - 오퍼랜드의 개수에 따라 여러 개의 필드로 구성될 수 있다.
      - ![Alt text](/images/5-3-0.png)
    - 명령어 형식 : 명령어 내 필드들의 수와 배치 방식 및 각 필드의 비트 수
    - 명령어의 길이 = 단어 길이
    - 연산 코드 필드 길이 : 연산의 개수를 결정
      - 만약 4 비트라면 2^4 = 16가지의 연산 정의 가능
      - 만약 연산 코드 필드가 5비트로 늘어나면 32가지 연산 가능
      - 일반적으로 8비트 정도로 구성되는 경우가 많다.
    - 오퍼랜드 필드의 길이 : 오퍼랜드의 범위 결정, 즉 데이터 표현 범위, 레지스터 크기, 메모리 크기를 결정할 수 있는 것이다.
      - 오퍼랜드의 종류에 따라 범위가 다름, 피연산자에 해당하는 내용의 길이를 결정할 수 있다.
      - 데이터 : 표현 가능한 수의 크기가 결정됨
      - 기억장치 주소 : cpu가 오퍼랜드 인출을 위하여 직접 주소를 지정할 수 있는 기억장치 영역의 범위가 결정
      - 레지스터 번호 : 데이터 저장에 사용될 수 있는 레지스터의 수가 결정됨
      - 만약, 오퍼랜드1이 4비트이고 레지스터 번호 지정시 : 16개의 레지스터 사용 가능
      - 오퍼랜드2는 8비트이고 기억장치 주소를 지정시 : 기억장치 주소 범위는 0~255번지 까지이다.
      - 위의 두 오퍼랜드를 하나로 통합해 사용시 오퍼랜드가 2의 보수로 표현되는 데이터라면 표현 범위는 -2^11 ~ 2^11-1 까지 이다.
      - 기억장치 주소라면 2^12 개의 기억장치 주소 지정 가능하다.
    - 오퍼랜드 수에 따른 명령어 분류
      - 0-주소 명령어 : return과 같은 명령어. 오퍼랜드가 필요없음.
      - 1-주소 명령어 : 오퍼랜드를 한 개만 포함하는 명령어
        - ex) ADD X : AC <- AC + M[X]
        - 혹은 스택을 사용하여 저장하는 경우
        - ![Alt text](/images/5-3-1.png)
      - 2-주소 명령어 : 두 개의 오퍼랜드를 포함하는 명령어(일반적으로 많이 사용됨)
        - ex) ADD R1, R2 : R1 <- R1 + R2
        - ex) MOV R1, R2 : R1 <- R2
        - ex) ADD R1, X : R1 <- R1 + M[X]
        - ![Alt text](/images/5-3-2.png)
      - 3-주소 명령어 : 세 개의 오퍼랜드들을 포함(최근에는 많이 쓰이지 않음. 명령어 길이 줄이기 위함)
        - ex) ADD R1, R2, R3  : R1 <- R2 + R3
        - ![Alt text](/images/5-3-3.png)
    - 명령어 형식이 프로그래밍에 미치는 영향(ex)
      - X=(A+B) * (C - D)
      - ADD ,SUB, MUL, DIV, MOV, LOAD, STOR만 있다고 가정시에
      - 1-주소 명령어를 사용한다면?
        - ![Alt text](/images/5-3-4.png)
        - 1-주소 명령만 있을 때는 항상 AC를 같이 사용할 수밖에 없다. 프로그램 길이가 7개임
      - 2-주소 명령만 가지고 사용시
        - ![Alt text](/images/5-3-5.png)
      - 3-주소 명령만
        - ![Alt text](/images/5-3-6.png)
      - 과연 저 경우 어느 것이 가장 좋은가라고 볼 때, 2-주소가 가장 좋다고 본다. 왜냐하면 메모리 엑세스가 많으면 많을수록 속도가 느려지고 명령어의 길이가 길어지면 해독과정도 복잡하기 때문이다.
      - 실제로는 0,1,2,3이 적절히 조합되어 CPU가 만들어진다.(3은 많이 쓰이지 않음.)
- 주소지정 방식
  - 다양한 주소지정 방식 사용 이유 : 제한된 수의 명령어 비트를 이용해 사용자로 하여금 오퍼랜드를 지정하고 더 큰 용량의 기억장치를 사용가능 토록 하기 위함
  - 기호
    - EA : 유효주소(Effective Address), 즉 데이터가 저장된 기억장치의 실제 주소
    - A : 명령어 내의 주소 필드 내용(오퍼랜드 필드가 기억장치 주소를 나타내는 경우)
    - R : 명령어 내의 레지스터 번호(오퍼랜드 필드가 레지스터 번호를 나타내는 경우)
    - (A) : 기억장치 A 번지의 내용
    - (R) : 레지스터 R의 내용
  - 종류
    - 직접 주소 지정
    - 간접 주소 지정
    - 묵시적 주소 지정
    - 즉치 주소 지정
    - 레지스터 주소지정
    - 레지스터 간접 주소지정
    - 변위 주소 지정(사실 더 많다)
      - 상대 주소지정
      - 인덱스 주소지정
      - 베이스-레지스터 주소지정
  - 직접 주소지정
    - 오퍼랜드 필드의 내용이 유효 주소가 되는 방식 : EA = A
    - 장점 : 데이터 인출을 위해 한 번의 기억장치 엑세스만 필요
    - 단점 : 연산 코드를 제외하고 남은 비트들만 주소 비트로 사용가능하여 직접 지정 가능 장소의 수가 제한됨.
  - 간접 주소지정
    - 최근에는 많이 사용되지 않음. 레지스터 간접 주소 지정을 더 많이 씀
    - 오퍼랜드 필드에 기억장치 주소가 저장되어 있지만, 그 주소가 가리키는 기억 장소에 데이터의 유효 주소가 저장되어 있는 방식
    - 즉, 메모리 엑세스를 2번 하게 된다.
    - EA = (A)
    - 장점 : 최대 기억장치용량이 단어의 길이에 의해 결정 -> 확장 가능
      - 단어 길이가 n비트면 최대 2^n 개의 기억 장소 지정 가능
    - 단점 : 엑세스가 여러번이므로 속도가 느려짐
    - 형식에서 간접비트(I)필요. I = 0시 직접, 1이면 간접
  - 묵시적 주소지정
    - 데이터의 위치가 묵시적으로 지정되어 있음. 위치를 짐작가능
    - SHL 명령어 : 누산기의 내용을 좌측으로 쉬프트 - shift-left하라
    - PUSH R1 명령어 : 레지스터 R1의 내용을 스택에 저장
    - 장점 : 명령어 길이가 짧다
    - 단점 : 종류가 제한된다 
  - 즉치 주소지정
    - 데이터가 명령어에 포함되어 있는 방식(오퍼랜드 필드의 내용이 연산에 사용할 실제 데이터)
    - 보통 프로그램에서 레지스터들이나 변수의 초기 값을 어떤 상수값으로 세트시 유용함
    - 장점 : 데이터 인출하려고 메모리 엑세스할 필요 없음
    - 단점 : 상수값의 크기가 오퍼랜드 비트 수에 의해 제한
  - 레지스터 주소지정
    - 연산에 사용할 데이터가 레지스터에 저장되어 있는 방식 : EA = R
    - 주소지정에 사용 가능 레지스터의 수 : 2^k개
    - 장점 : 오퍼랜드 필드의 비트 수가 적어도 됨(레지스터의 개수). 데이터 인출을 위해 메모리 엑세스 필요 없다
    - 단점 : 데이터 저장 공간이 CPU 내부 레지스터로 제한
  - 레지스터 간접 주소지정
    - 오퍼랜드 필드가 가리키는 레지스터의 내용을 유효 주소로 써서 실제 데이터 인출 : EA = (R)
    - 즉, 레지스터에 있는 주소로 메모리에 접속하여 1번만 메모리 접속
    - 장점 : 주소 지정 가능한 기억장치 영역 확장. 레지스터의 길이가 16비트면, 주소지정 영역 : 2^16 = 64K 바이트, 32면 4G
  - 변위 주소지정
    - 직접 주소 + 레지스터 간접주소지정 : EA = A + (R)
    - PC사용시 :  상대 주소지정
    - 인덱스레지스터 : 인덱스 주소지정
    - 베이스레지스터 : 베이스-레지스터 주소지정
    - 실제로는 이보다 훨씬 많은 종류가 있다.
  - 상대 주소지정방식
    - 프로그램 카운터를 레지스터로 사용 : EA = A + (PC)
    - A >= 0 : 앞방향 분기, A < 0 : 뒷 방향 분기
    - 장점 : 전체 기억장치 주소가 명령어에 포함되어야 하는 일반적인 분기 명령어보다 적은 수의 비트만 필요
    - 단점 : 분기 범위가 오퍼랜드 필드의 길이에 의해 제한
  - 인덱스 주소지정
    - 인덱스 레지스터의 내용과 변위 A를 더해 유효주소 결정 : EA = (IX) + A
    - IX : 인덱스 값을 저장하는 특수 레지스터
    - 용도 : 배열 데이터 엑세스
    - 자동 인덱싱
      - 명령어가 실행될 떄마다 인덱스 레지스터의 내용이 자동으로 증가 혹은 감소함
      - 이 방식이 사용된 명령어가 실행시 아래 연산이 연속
        - ex) EA = (IX) +A , IX <- IX + 1
  - 베이스-레지스터 주소지정
    - 베이스 레지스터의 내용 + 변위 A : EA = (BR) + A
    - 주요 용도 : 서로 다른 세그먼트내 프로그램의 위치 지정
- 실제 상용 프로세서들의 명령어 형식
  - PDP - 10 프로세서 : 고정 길이의 명령어 형식 사용
    - 단어 길이 36비트, 명령어 길이 최대 36비트
    - 연산 코드 : 9비트 -> 최대 512 종류 연산(실제 365개)
  - PDP - 11 프로세서 : 다양한 길이의 명령어 형식 사용
    - 연산 코드 = 4~16비트
    - 주소 개수 : 0, 1, 2 개
  - 펜티엄 프로세서의 명령어 형식
    - 선형 주소(LA) : 유효 주소 + 세그먼트의 시작 주소
    - 즉치 방식
    - 레지스터 방식
    - 변위 방식
    - 베이스 방식
    - 상대 방식 등 사용
