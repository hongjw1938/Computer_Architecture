### I/O 장치의 접속
- I/O제어
  - 장치가 시스템 버스에 직접 접속되지 못하는 이유
    - 장치들이 종류에 따라 제어 방법이 서로 다름. 제어 회로들을 CPU 내부에 모두 포함시키는 것이 불가능. 따라서 직접 제어 불가
    - 장치들의 데이터 전송 속도가 CPU의 데이터 처리 속도에 비해 너무 느림. 따라서 고속의 시스템 버스와 I/O장치들 사이에 직접 데이터 교환 불가
    - 장치간 데이터 형식의 길이가 서로 다른 경우 많음
    - 이에 따라 인터페이스 장치인 I/O 제어기(controller)를 사용
  - 제어기 주요 기능
    - 장치 제어 및 타이밍 조정
    - CPU와의 통신 담당
    - I/O 장치와의 통신 담당
    - 데이터 버퍼링 기능 수행
    - 오류 검출
    - 예) 프린터 제어기
      - ![Alt text](/images/16-0.png)
  - 상태/제어 레지스터
    - 내부적으로 두 개의 레지스터로 구성되나 주소는 하나만 지정되는 레지스터들
    - 상태 레지스터 : I/O 장치의 상태와 오류 검사 결과 등을 나타내는 비트들로 구성
    - 제어 레지스터 : CPU가 보낸 입출력명령 단어를 저장
    - 프린터로 출력하는 과정
      - CPU가 프린터 제어기에게 프린터의 상태 검사토록 요청
      - 제어기는 프린터의 상태 검사해 CPU에 통보
      - 데이터를 받을 준비가 된 상태면, CPU는 제어기에게 출력 명령과 데이터 전송
      - 제어기는 프린트 동작을 위한 제어 신호화 함께 프린터로 전송
  - 프로그램을 이용한 IO(제어기 없이)
    - CPU가 반복적으로 IO 장치의 상태를 검사하며 IO 동작을 처리하는 방식
    - 장점 : 간단, 별도의 하드웨어 필요 없음
    - 단점 : CPU가 IO 동작에 직접 관여하므로, 그동안 다른 일을 못함.
    - 주로 작은 장치들 같은 경우에서 많이 사용됨.
    - ![Alt text](/images/16-1.png)
  - IO 주소 지정
    - 각 장치당 두 개씩의 주소 할당
      - 데이터 레지스터 주소 및 상태/제어 레지스터 주소
    - 주소 지정 방법
      - 기억장치 사상 IO
        - 기억장치 주소 영역의 일부분을 IO 제어기 내의 레지스터들의 주소로 할당하는 방식
        - 프로그래밍에서 기억장치 관련 명령어들을 IO 장치 제어에도 사용 가능
          - LOAD 명령어, STORE 명령어 등..
        - 기억장치 읽기/쓰기 신호를 IO 읽기/쓰기 신호로 사용
        - 주소 공간 할당 예
          - 주소 비트들이 10비트 - 전체 기억 장소 : 1024개
          - 0~511번지 (상위 512개) : 기억장치 할당
          - 512~1023  : IO에 할당
          - ![Alt text](/images/16-2.png)
        - 장점 : 프로그래밍 용이
        - 단점 : 기억장치 주소 공간 감소(실제로 요즘은 용량이 커서 Io 장치는 조금만 할당됨) 큰 문제 아님
      - 분리형 IO(독립형)
        - IO 장치 주소공간을 기억장치 주소 공간과는 별도로 할당하는 방식
        - IO 제어를 위해 별도의 IO 명령어 사용(IN, OUT 명령어)
        - 별도의 읽기/쓰기 신호 필요
        - ![Alt text](/images/16-3.png)
          - 주의 : 데이터 레지스터와 상태/제어 레지스터 주소가 기억장치에 할당되는 것이 아니라는 것.
        - ![Alt text](/images/16-4.png)
