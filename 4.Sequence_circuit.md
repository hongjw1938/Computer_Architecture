### 순서논리회로
- 참조
  - 메모리를 갖는다.
  - 앞의 출력 상태가 기반이 되어(즉 피드백 되어) 다음의 입력으로 이어짐
    - 귀환(FeedBack) : 되먹임. 즉 다시 돌아오는 것. 게이트의 출력이 회로 내 다른 게이트의 입력으로 다시 연결되는 것을 의미한다.
  - 예를 들면 디지털 시계. 1초 지날 때마다 갱신됨.
- 래치, 플립- 플롭 및 레지스터
- 클럭 : 일정시간에 맞추어 0, 1 이 반복되는 입력. 각 유지 기간이 동일하면 이상적. 해당 주기가 일정하게 반복됨.
  - 래치
    - Q를 기존 출력으로 함. Q' 는 다음 상태 입력을 컨트롤하기 위해 사용됨.
    - ![Alt text](/images/4-0.png)
    - 래치는 클럭 입력을 가지지 않는 기억소자로 SR래치와 D 래치가 있다. 클럭을 가지는 경우는 D 래치인데 가지더라도 1이 유지되는 상태에서만 작동함. 래치는 거의 사용되지 않음. 대체로 플립플롭사용
    - S-R래치(Set-Reset Latch)
      - NOR 게이트를 이용해서 만들며, NAND를 이용하기도 한다.
      - 입력 R이 연결된 게이트의 출력을 다시 S가 연결된 게이트의 입력으로 보낸다. 또 입력 S가 연결된 게이트의 출력을 다시 R이 연결된 게이트의 입력으로 보낸다. 이것이 귀환
        - R=1, S=0 입력시 Q=0, Q'=1이 됨
        - 출력 Q=0 값이 다시 입력 S가 연결된 입력으로 들어감
        - 0,0이 입력되고 NOR 게이트에 의해 1이 출력
        - 출력된 1이 R이 입력된 게이트에 들어가서 1, 1이 되고 0 출력
        - Q=0이 되고 위 과정이 반복됨
      - 진리표
        - ![Alt text](/images/4-1.png)
        - 현재출력과 입력 값에 의해 다음 출력이 결정되는 것이다.
        - 즉, 0 0 이면 이전의 값이 그대로 출력된다..
        - S=1이면 다음값은 1이되며, R=1이면 다음 값은 0 이다.
        - 둘 다 1 1 인 경우는 허용되지 않는다. 왜냐하면 '래치출력은 서로 보수가 되어야하는 래치 동작의 기본 규칙'을 위배하기 때문이다. Q와 Q'가 같은 값이면 안된다.
    - 게이트형 D 래치
      - SR 래치 앞에 AND 게이트가 있고 입력 D와 SR 래치 동작을 제어하는 G 입력으로 구성된다.
      - ![Alt text](/images/4-2.png)
      - 따라서 게이트형 D 래치는 G=0이면 S=R=0 으로 Q가 이전 값을 유지한다. G=1 이면 Q=D
  - 플립플롭
    - 클럭 입력을 가져 클럭 입력에 반응하여 출력의 상태를 바꾼다.
    - 즉, 0 -> 1 이 되거나 1 -> 0 이 될 때 반응하여 동작함.
    - Master-slave D flip-flop 혹은 개별적인 flip-flop. 회로도에 삼각형 표시가 있으면 플립플롭. 아니면 래치
    - 플립플롭을 여러개를 합쳐서 k-bit register를 만들 수 있다.
    - 에지트리거 D 플립플롭
      - SR 플립플롭의 부정을 제거하기 위해 만들어짐
      - 클럭은 출력을 제어하는 입력이다.
      - ![Alt text](/images/4-3.png)
      - ![Alt text](/images/4-4.png)
      - 하강에지트리거는 상승에서 클럭에 버블을 붙인 것.
      - 에지라는 것은, 상승의 경우 0->1이 되는 구간, 하강은 1->0이 되는 구간을 의미함.
      - ![Alt text](/images/4-5.png)
    - SR 플립플롭
      - 실제로 부정이 있어서 잘 사용되지는 않는다.
      - 레벨 트리거
      - ![Alt text](/images/4-6.png)
    - J-K 플립플롭
      - SR을 확장한 것으로 부정입력을 없애기 위해서 만든 것이다.
      - J와 K가 둘 다 1 1 일 때만 다름.
      - ![Alt text](/images/4-7.png)
    - T 플립플롭
      - J-K를 묶어서 하나도 사용하는 것.
      - ![Alt text](/images/4-8.png)
      - 위에 보듯이 하나도 입력해서 01 10 으로 입력하는 경우는 없다. 00 11만 입력할 수 있고 0일 때는 불변, 1일 때는 toggle이 된다.
    - 에지 트리거 S-R 플립플롭
      - 상승 혹은 하강에 따라 동작하는 것. 진리표 자체는 S-R 플립플롭과 동일하다. 
    - S-R 플립플롭의 여기표
      - ![Alt text](/images/4-9.png)
      - 플립플롭의 상태를 변화시키기 위해서 출력을 어떻게 입력으로 만들었을 때 변화시키느냐를 보여주는 것.
      - Q(t) : 0 -> Q(t+1) : 0 이 되는 경우는 S R 이 0 0, 0 1 인 경우이다. R은 X, 즉 don't care
      - 1 -> 0 : S : 0 R: 1, 0 -> 1 : S : 1, R : 0, 1 -> 1 : X, 0
    - J-K 플립플롭의 여기표(중요)
      - ![Alt text](/images/4-10.png)
      - 차기 상태를 위해 요구되는 입력(여기표)를 확인한다.
    - ![Alt text](/images/4-11.png)
    - D는 현재와 관계없이 요구 입력을 집어넣으면 변화함
    - T는 상태 변하면 0, 변하면 1
- 동기식 카운터, 비동기식 카운터
  - 동기식 카운터
    - 모든 플립플롭의 클럭이 동시에 입력되는 것
    - 원하는 순서대로 마음대로 설계 가능
    - 3비트 2진 동기식 카운터
      - ![Alt text](/images/4-12.png)
      - 위와 같은 형태로 계속 순환. 현재 상태에서 다음 상태로 순환함.
      - 000 -> 001로 변한다면 J-K플립플롭의 여기표에 따라서 A는 J : 0, K : X, B는 J : 0, K : X, C는 J : 1, K : X
      - ![Alt text](/images/4-13.png)
      - T플립플롭을 이용하는 경우
      - ![Alt text](/images/4-14.png)
  - 비동기식 카운터
    - 비동기 카운터는 첫 번째 플립플롭의 CP 입력에만 클록펄스가 입력되고, 다른 플립플롭은 각 플립플롭의 출력을 다음 플립플롭의 CP입력으로 사용한다.
    - 끝점과 시작점만 설계 가능
    - 플립플롭의 출력 전이가 다른 플립플롭을 트리거시키는 원인으로 작용한다.
    - 비동기 카운터는 ripple 카운터라고도 한다.
    - J-K 또는 T 플립플롭을 사용해 구성한다.
    - 상향/하향 카운터가 있다.
      - ![Alt text](/images/4-15.png)
      - 하강엣지인 경우
      - 상향인 경우 또한 비슷하다.(상승 엣지일 때 상태변화 함)
    - 비동기 10진 카운터(BCD 카운터, Modulo- m 카운터)
      - 10까지만 카운트함. 목표치보다 + 1에 도달하면 모든 플립플롭을 0으로 clear한다.
      - ![Alt text](/images/4-16.png)
      - 이 카운터를 3개 붙이면 0~999까지 카운트 가능
    - 프리세트 카운터
      - 0보다 큰 수로부터 카운터 시작
      - 생략
