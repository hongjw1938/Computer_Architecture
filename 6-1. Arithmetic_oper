### 컴퓨터 산술과 논리 연산
- ALU의 구성 요소
  - 구성
    - 산술 연산 장치
    - 논리 연산 장치
    - 시프트 레지스터 : 비트들을 좌측 혹은 우측으로 이동시키는 기능을 가진 레지스터
    - 보수기 : 2진 데이터를 2의 보수로 변환(음수화)
    - 상태 레지스터 : 연산 결과의 상태를 나타내는 플래그들을 저장하는 레지스터
- 값의 표현
  - 2진수 체계 : 0, 1, 부호 및 수소점으로 수를 표현
  - n-비트 2진수를 부호 없는 정수 A로 변환 : A=a_n-1 * 2^(n-1) + .. + a_0 * 2^0
  - 소수의 경우에는 2에서 -1, -2, -3 제곱을 해가면서 곱하면 됨.
  - 정수
    - 부호가 있는 정수
    - 부호가 없는 정수 : 정수를 2로 계속 나누어서 남은 나머지를 사용해서 표현
    - 음수 표현 방법
      - 부호화-크기 표현(signed-magnitude repre)
        - 맨 좌측 비트는 부호 비트, 나머지 n-1개의 비트는 수의 크기를 나타냄.
        - 예) +9 = 0 0001001
        - -9 = 1 0001001
        - 실제 연산시 매우 복잡한 방법이 동원되어야 하기에 실제로는 사용되지 않는다.
        - 0에 대한 표현이 두 개 존재하여 표현할 수 있는 수가 1개 더 제한됨
      - 1의 보수 표현(1's complement repre)
        - 모든 비트를 반전(0 -> 1, 1 -> 0)
        - 이것도 표현이 하나 더 제한되는 단점
        - 0이 00000000과 11111111로 두 개임
        - -(2^(n -1)  - 1) ~ + (2&^(n-1) + 1) 로 표현 됨.
      - 2의 보수 표현(2's complement repre) : 이것을 가장 많이 씀
        - 모든 비트를 반전하고 결과에 1을 더함
        - -2^(n-1) ~ + 2^(n-1) -1 까지 표현 가능
    - 2의 보수를 10진수 변환
      - 양수 : 단순히 a_n-2 부터 해서 2의 n-2를 곱해주면서 변환
      - 음수 : 맨 앞 n-1부분은 -2^(n-1)이 되고 이 값을 나머지 값에서 빼주면 된다. 혹은 2의 보수를 취하고 다시 -를 붙인다.
        - ![Alt text](/images/6-1-0.png)
    - 비트 확장
      - 데이터의 길이를 늘리는 방법
      - 목적 : 데이터를 더 많은 비트의 레지스터에 저장하거나 더 긴 데이터와의 연산 수행
      - 부호화-크기 표현시에는 비트가 늘어나면 다 0으로 채우면 된다.
      - 2의 보수의 경우는 확장되는 상위 비트를 부호 비트와 같은 값으로 세트한다.
        - ![Alt text](/images/6-1-1.png)
  - 실수 : 정수와 소수를 나누어서 표현한다. 
    - -13.625 -> 13을 계속 2로 나누어서 1 또는 0이 남을 때까지 지속한 후 나머지를 모은다. 소수점은 2를 계속 곱해서 소수점 아래가 남지 않을 때까지 곱하고 곱한 뒤의 1의 자리수를 사용한다. -> -1101.101_2가 된다.
    - 여기서 부호가 있으니까 추가로 변환해야 한다.(위 비트확장, 2의 보수 참조)
- 논리 연산
  - AND, NOT, OR, XOR 연산 - 논리회로 참조
  - N-비트 논리 연산장치
    - N-비트 데이터들을 위한 논리 연산장치로 기본 논리 모듈들을 병렬로 접속함.
  - AND, OR 연산등은 그림, 영상등을 처리시에 많이 사용
  - 선택적-세트 연산
    - B 레지스터의 비트들 중에서 1로 세트된 비트들과 같은 위치에 있는 A레지스터의 비트들을 1로 세트(OR 연산 이용)
    - 필요한 부분만 1로 바꿔주고 싶을 때 사용하는 연산 방식
    - ![Alt text](/images/6-1-2.png)
  - 선택적-보수 연산
    - B 레지스터의 비트들 중에서 1로 세트 된 비트들에 대응되는 A 레지스터의 비트들을 보수로 변환(XOR 연산 이용)
    - 즉, 서로 다른 부분만 남기고 싶은 경우
  - 마스크 연산
    - B 레지스터의 비트들 중에서 값이 0인 비트들과 같은 위치에 있는 A 레지스터의 비트를 0으로 바꾸는 연산(AND연산)
    - 단어내의 원하는 비트를 선택적으로 clear시 사용
  - 삽입 연산
    - 새로운 비트 값들을 데이터 단어내의 특정 위치에 삽입
    - 삽입할 비트 위치들에 대해 마스크 연산 수행 후 새로이 삽입할 비트들과 OR 연산 수행(AND 후 OR)
  - 비교 연산
    - XOR 연산 사용. A, B 레지스터의 내용을 비교
    - 모든 비트가 같다면 결과는 다 0. Z 플래그를 플래그 레지스터에 1로 세트
- 시프트 연산
  - 논리적 시프트 : 레지스터 내의 데이터 비트들을 왼쪽 혹은 오른쪽으로 한 칸씩 이동
    - 좌측 시프트 : 모든 비트를 좌측 이동. 최하위에는 0이 들어오고 최상위는 버림
    - 우측 시프트 : 모든 비트 우측 이동. 최상위 비트는 0이 들어오고 최하위는 버림
  - 순환 시프트
    - 회전이라고도 부르며, 최상위 혹은 최하위에 있는 비트를 버리지 않고 반대편 끝에 있는 비트 위치로 이동
    - 순환 좌측-시프트 : 최상위가 최하위로
    - 순환 우측-시프트 : 최하위가 최상위로
    - 직렬 데이터 전송(serial data transfer)
      - 병렬데이터를 직렬데이터로 바꿀 때 이를 사용함.
      - ![Alt text](/images/6-1-3.png)
      - 시프트 하면서 A는 계속 rotate하고 B는 4클럭이 지나면 해당 내용이 그대로 복사해서 나가게 됨.
  - 산술적 시프트
    - 수를 나타내는 데이터에 대한 시프트
    - 방법 : 시프트 과정에서 부호 비트는 그대로 유지하고, 수의 크기를 나타내는 비트만 시프트
    - 실제 C, Java에서 사용되는 시프트
    - 산술적 좌측 시프트 : 1회에 2씩 곱함, 0이 최하위로 계속 들어옴
    - 산술적 우측 시프트 : 1회에 1/2씩 곱함, 부호비트가 최상위로 계속 들어옴
    - ![Alt text](/images/6-1-4.png)
  - C 플래그를 포함한 시프트 연산
    - 즉 캐리를 사용하는 것. 
    - C 플래그를 포함한 좌측 시프트 - SHLC
    - 우측 - SHRC
    - 이는, 시프트시 최상위를 버리지 않고 캐리에 저장하는 것이다. 더 큰 수치의 연산을 위해서 사용할 수 있다. 우측 시프트 시에는 캐리의 값이 최상위로 들어오게 된다.
    - RLC : rotate left with carry : c 플래그를 포함하는 좌측 순환 시프트
    - RRC : c 플래그를 포함하는 우측 순환 시프트


