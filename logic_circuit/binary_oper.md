### 수의 연산
- 수를 불대수에서 표현, 덧셈/뺄셈 연산 구현
- 수의 표현
  - 우리가 쓰는 수  : 10진수
    - 0~9까지 10개의 기호로 표현한다.
    - 기호들의 조합을 통해서 수를 계속해서 크게 표현할 수 있다.
- 불대수 값
  - 참과 거짓
  - 2진수 : 2개의 기호
    - 0 1 10 11 100 101 110 111...
  - 논리회로 : 자릿수가 고정되어 있다.
    - 만약 3자리로 수를 표현한다면 000~ 111 까지라면 0~7까지로 모든 것을 표현
    - N자리 라면 2^N -1까지
    - 각각의 자리는 비트
  - 16진수는?
    - 0~9, A~F 까지. 변환은 2진수와 같음
  - 음수의 표현
    - -3 , +3 : 부호화크기 방식
      - 2진수로는 10011, 00011 등으로 사용
      - 이 체계는 별로 좋지 않다. 0이 2개이며 부호에 따라 연산이 복잡해지기 때문이다.(3단계임. 부호 구분, 큰 수 구분, 큰 수에 따라 연산)
    - 2의 보수체계
      - 음수 -N을 N* = 2^n - N의 2진수 표기로 표현
      - 예) 4bit에서 -3을 2의 보수로 표현한다면?
        - N* = 2^4-3 = 13 = 1101_2
      - 예) 5bit에서 -12 표현
        - N* = 2^5 - 12 = 32-12 = 20 = 10100_2
      - 이에 따라 -2^(n-1) ~ 2^(n-1)-1 까지 표현가능
      - 2의 보수의 장점
        - 연산이 2진수 연산과 동일
          - ex) -3+(-4) = -7이다. 1101_2 + 1100_2 = 1001_2
          - 1001_2는 -7의 2의 보수 표기임. 즉, 단순 덧셈연산으로 표현 가능
        - 음수 양수 구별이 쉽다
        - 0의 표현이 한 개임
      - 2의 보수 변환법
        - 2진수 표현(-제외하고)
        - 각 자리 보수화
        - +1
  - overflow
    - 4비트 연산에서 5+7을 해보면? 0101 + 0111 = 1100 -> -4의 2의 보수표현
    - 오버플로우는 양수+양수, 음수+음수 에서만 발생
    - MSB : Most significant Bit
      - 두 입력의 MSB가 0인데 연산 후 1 , 1인데 연산 후 0 이면 오버플로우