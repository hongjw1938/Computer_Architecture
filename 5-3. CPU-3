### CPU3
- 명령어 세트
  - 구성요소
    - 연산코드 : 실제 수행될 연산(Load, Add 등 100개~200개 수준)
    - 오퍼랜드 : 연산을 수행하는 데 필요한 데이터 혹은 데이터 주소
      - 각 연산은 한 개 혹은 두 개의 입력 오퍼랜드와 한 개의 결과 오퍼랜드를 포함한다.
    - 다음 명령어 주소 : 오퍼랜드의 한 종류로 볼 수 있다.
      - 현재의 명령어 실행이 완료 후 다음 명령어를 인출할 위치 지정
      - 분기 혹은 호출 명령어와 같이 실행 순서 변경시 필요
  - 명령어 형식
    - 필드 : 명령어의 각 구성 요소에 소요되는 비트(연산코드, 오퍼랜드)
      - 오퍼랜드의 개수에 따라 여러 개의 필드로 구성될 수 있다.
      - ![Alt text](/images/5-3-0.png)
    - 명령어 형식 : 명령어 내 필드들의 수와 배치 방식 및 각 필드의 비트 수
    - 명령어의 길이 = 단어 길이
    - 연산 코드 필드 길이 : 연산의 개수를 결정
      - 만약 4 비트라면 2^4 = 16가지의 연산 정의 가능
      - 만약 연산 코드 필드가 5비트로 늘어나면 32가지 연산 가능
      - 일반적으로 8비트 정도로 구성되는 경우가 많다.
    - 오퍼랜드 필드의 길이 : 오퍼랜드의 범위 결정, 즉 데이터 표현 범위, 레지스터 크기, 메모리 크기를 결정할 수 있는 것이다.
      - 오퍼랜드의 종류에 따라 범위가 다름, 피연산자에 해당하는 내용의 길이를 결정할 수 있다.
      - 데이터 : 표현 가능한 수의 크기가 결정됨
      - 기억장치 주소 : cpu가 오퍼랜드 인출을 위하여 직접 주소를 지정할 수 있는 기억장치 영역의 범위가 결정
      - 레지스터 번호 : 데이터 저장에 사용될 수 있는 레지스터의 수가 결정됨
      - 만약, 오퍼랜드1이 4비트이고 레지스터 번호 지정시 : 16개의 레지스터 사용 가능
      - 오퍼랜드2는 8비트이고 기억장치 주소를 지정시 : 기억장치 주소 범위는 0~255번지 까지이다.
      - 위의 두 오퍼랜드를 하나로 통합해 사용시 오퍼랜드가 2의 보수로 표현되는 데이터라면 표현 범위는 -2^11 ~ 2^11-1 까지 이다.
      - 기억장치 주소라면 2^12 개의 기억장치 주소 지정 가능하다.
    - 오퍼랜드 수에 따른 명령어 분류
      - 0-주소 명령어 : return과 같은 명령어. 오퍼랜드가 필요없음.
      - 1-주소 명령어 : 오퍼랜드를 한 개만 포함하는 명령어
        - ex) ADD X : AC <- AC + M[X]
        - 혹은 스택을 사용하여 저장하는 경우
        - ![Alt text](/images/5-3-1.png)
      - 2-주소 명령어 : 두 개의 오퍼랜드를 포함하는 명령어(일반적으로 많이 사용됨)
        - ex) ADD R1, R2 : R1 <- R1 + R2
        - ex) MOV R1, R2 : R1 <- R2
        - ex) ADD R1, X : R1 <- R1 + M[X]
        - ![Alt text](/images/5-3-2.png)
      - 3-주소 명령어 : 세 개의 오퍼랜드들을 포함(최근에는 많이 쓰이지 않음. 명령어 길이 줄이기 위함)
        - ex) ADD R1, R2, R3  : R1 <- R2 + R3
        - ![Alt text](/images/5-3-3.png)
    - 명령어 형식이 프로그래밍에 미치는 영향(ex)
      - X=(A+B) * (C - D)
      - ADD ,SUB, MUL, DIV, MOV, LOAD, STOR만 있다고 가정시에
      - 1-주소 명령어를 사용한다면?
        - ![Alt text](/images/5-3-4.png)
        - 1-주소 명령만 있을 때는 항상 AC를 같이 사용할 수밖에 없다. 프로그램 길이가 7개임
      - 2-주소 명령만 가지고 사용시
        - ![Alt text](/images/5-3-5.png)
      - 3-주소 명령만
        - ![Alt text](/images/5-3-6.png)
      - 과연 저 경우 어느 것이 가장 좋은가라고 볼 때, 2-주소가 가장 좋다고 본다. 왜냐하면 메모리 엑세스가 많으면 많을수록 속도가 느려지고 명령어의 길이가 길어지면 해독과정도 복잡하기 때문이다.
      - 실제로는 0,1,2,3이 적절히 조합되어 CPU가 만들어진다.(3은 많이 쓰이지 않음.)
