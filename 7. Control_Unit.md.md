### 제어 유니트
- 제어 유니트(제어 장치) 의 기능
  - 명령어 코드 해독
  - 명령어 실행에 필요한 제어 신호들의 발생
  - 제어장치
    - Hardwired control
      - 하드웨어 논리회로를 기반으로 설계된 제어 시스템
      - 단점 : 한번 설계되면 조정이 매우 어려움, 변경이 거의 가능하지 않음
    - microprogrammed control
      - 소프트웨어를 기반으로 제어장치를 설계하는 것.
      - 마이크로명령어가 있음. 공개되지 않는 내용임.
        - 마이크로 명령어(micro-instruction)
          - 명령어 사이클의 각 주기에서 실행되는 마이크로-연산들에 대응되는 비트들로 이루어진 단어로서, 제어 단어라고도 함.
          - 기계어보다 더 작은 수준으로 이루어짐
      - 마이크로 프로그램 : 마이크로명령어들의 집합
- 루틴 : CPU의 특정 기능을 수행하기 위한 명령어들의 그룹, ex) 인출 사이클 루틴, 실행 사이클 루틴, 인터럽트 사이클 루틴
- 제어 장치 구조
  - 명령어 해독기(decoder)
    - 명령어 레지스터로부터 들어오는 명령어의 연산 코드를 해독해 해당 연산을 수행하기 위한 루틴의 시작 주소를 결정
  - 제어 주소 레지스터(control address register : CAR)
    - 다음에 실행한 마이크로명령어의 주소를 저장하는 레지스터
    - 이 주소는 제어 기억장치의 특정 위치를 지칭
  - 제어 기억장치
    - 마이크로명령어들로 이루어진 마이크로프로그램을 저장하는 내부 기억장치
  - 제어 버퍼 레지스터(CBR)
    - 제어 기억장치로부터 읽힌 마이크로 명령어 비트들을 일시적으로 저장
  - 서브루틴 레지스터(SBR)
    - 마이크로프로그램에서 서브루틴이 호출시 현재의 CAR 내용을 일시로 저장
  - 순서 제어 모듈(Sequencing module)
    - 마이크로명령의 실행 순서 결정하는 회로의 집합
  - ![Alt text](/images/7-0.png)
- CPU의 명령어 세트 설계 과정
  - 명령어 종류와 비트 패턴 정의
  - 명령어들의 실행에 필요한 하드웨어 설계
  - 각 명령어를 위한 실행 사이클 루틴 작성(마이크로프로그래밍)
  - 마이크로프로그램 코드들을 제어 기억장치에 저장
- 명령어 해독
  - 명령어의 연산 코드가 지정하는 연산을 위한 실행 사이클 루틴의 시작 주소를 결정하는 동작
  - 사상(mapping)을 이용한 해독 방법
    - 명령어의 연산 코드를 특정 비트 패턴과 조합
    - ![Alt text](/images/7-1.png)
- 마이크로명령어의 형식
  - 연산 필드가 두 개면, 두 개의 마이크로-연산들을 동시에 수행 가능
  - 조건(CD)필드는 분기에 사용될 조건 플래그 지정
    - 두 비트로 구성되며, 분기의 조건으로 사용
    - U : 무조건 분기
    - I : 만약 1이면 간접 사이클 루틴 호출
    - S : 부호가 1이면, 분기(음수)
    - Z : 데이터가 0이면, 분기
  - 분기(BR)필드는 분기의 종류와 다음에 실행할 마이크로명령어의 주소를 결정하는 방법 명시
    - 조건 필드의 조건이 만족시 ADF 필드의 내용을 CAR로 적재. 그 주소로 분기(JUMP 또는 CALL)
    - RET : 서브루틴에서 복귀 - SBR에 저장된 내용을 CAR로 적재
    - MAP : 사상 방식에 의해 분기 목적지 주소 결정
  - 주소 필드(ADF)의 내용은 분기가 발생하는 경우에 목적지 마이크로명령어의 주소로 사용
- 마이크로프로그래밍
  - 인출 사이클 루틴의 마이크로명령어 루틴
    - 인출사이클은 메모리에서 데이터를 읽어오는 사이클을 의미
    - 주소 : 각 마이크로명령어가 저장될 제어 기억장치 주소
    - u-pos : 두 개의 마이크로연산들, cd : 조건 필드, br : 분기 필드, adf : 주소 필드
    - ![Alt text](/images/7-2.png)
    - 위는 예시
  - 간접 사이클 루틴
    - 메모리를 2번 엑세스한다.
    - ![Alt text](/images/7-3.png)
  - 실행 사이클 루틴
    - 사상 방식을 이용해 각 연산 코드에 대한 실행 사이클 루틴의 시작 주소를 결정하고, 각 명령어 실행을 위한 루틴 작성
    - ![Alt text](/images/7-4.png)
    - 여기서는 사상 함수가 앞에 1, 뒤에 00을 붙이는 방식임., NOP : no operation. 아무것도 하지 않음.
    - ![Alt text](/images/7-5.png)
    - NOP는 프로그램카운터만 하나 증가시키고 인출 사이클로 점프함
    - LOAD는 만약 조건이 Indirect면 간접 사이클로 점프하고, 아니라면 주소를 MAR로 보내고 데이터를 읽어서 AC에 누적
    - 나머지도 조건, 분기에 따라 명령어를 해독하여 제어한다.
- 마이크로프로그램의 순서제어
  - 순서제어 : 다음에 실행할 마이크로명령어의 주소 결정
  - CAR의 초기값 = 0
    - 인출 사이클 루틴의 첫 번째 마이크로명령어의 주소
  - MUX1 : 다음에 실행할 마이크로명령어의 주소 선택
  - MUX2 : 조건 플래그를 선택하여 주소선택 회로로 전송
  - ![Alt text](/images/7-6.png)
    - MUX1은 주소선택 회로에서 s1, s0의 값에 따라 0,1,2,3으로 신호가 와서 어떤 주소를 선택할지 결정된다.
    - MUX2는 조건을 선택하는 것. 조건 분기에 따라 어떻게 실행할 것인지 결정되는 것이다.
  - 주소 선택 방법
    - BR = 00 혹은 01 일때, C=0(다음 위치의 마이크로명령어 선택), C=1(주소 필드가 지정하는 위치로 점프 혹은 호출)
    - BR = 10이면 SBR을 CAR로 적재 : return
    - BR = 11이면 MAP이므로 사상 결과를 CAR에 적재
  - 제어 신호의 생성
    - 제어 기억장치로부터 인출된 마이크로명령어 내 연산필드의 비트들이 제어 유니트의 외부로 출력되어, 각각 제어 신호로 사용됨
    - 메모리, I/O, ALU등 신호가 이동하여 작동함.
  - 수직적 마이크로프로그래밍
    - 마이크로명령어의 연산 필드에 적은 수의 코드화된 비트들을 포함시키고, 해독기를 이용해 그 비트들을 필요한 수 만큼의 제어 신호로 확장하는 방식 - 3*8디코더 와 같은 것을 사용(3개 입력으로 8개의 신호)
    - 장점 : 마이크로명령어의 길이 최소화 : 제어 기억장치 용량 감소
    - 단점 : 해독 동작에 걸리는 만큼의 지연 시간 발생, 추가적인 하드웨어가 필요함
  - 수평적 마이크로프로그래밍
    - 연산 필드의 각 비트와 제어 신호를 1:1로 대응시키는 방식
    - 필요한 제어 신호 수만큼의 비트들로 이루어진 연산필드 비트들이 마이크로명령어에 포함되어야 함.
    - 장점 : 하드웨어가 간단, 해독에 따른 지연 시간 없음
    - 단점 : 마이크로명령어의 비트 수가 길어지므로 제어 기억장치의 용량이 증가
