5-1. CPU의 기능
- 명령어 인출(fetch)
  - 기억장치로부터 명령어를 읽어온다.
- 명령어 해독(decode)
  - 제어장치가 수행. 제어장치는 CPU의 가장 중요하고 복잡한 부분임
  - 수행할 동작을 결정하기 위해 명령어 해독
  - 인출 - 해독 과정을 모든 명령어에 대해 공통적으로 수행함
- 데이터 인출(Data fetch)
  - 명령어 실행을 위해 데이터가 필요시 기억장치 또는 I/O 장치로부터 그 데이터를 읽어옴
- 데이터 처리(Data process)
  - 데이터에 대한 산술적 혹은 논리적 연산 수행
- 데이터 쓰기(Data store)
  - 수행 결과 저장
  - 데이터 인출 - 처리 - 쓰기는 명령어에 따라 필요한 경우 수행
- CPU의 기본 구조(아래 세가지는 필수)
  - 산술논리연산장치(ALU : Arithmetic and Logical Unit)
    - 말그대로 산술연산, 논리연산을 수행하는 회로로 이루어진 하드웨어 모듈
    - 산술연산 : +, *, /, -
    - 논리연산 : AND, OR, NOT, XOR
  - 레지스터 세트(Register Set)
    - 일반 / 특수로 나뉨
    - CPU가 데이터를 처리하는 과정 속에서 필요한 데이터를 잠시 저장하는 CPU 속의 메모리라고 보면 된다.
    - 엑세스 속도가 가장 빠르지만 용량이 작다
    - CPU 내부에 포함 가능한 레지스터 수는 제한됨.
  - 제어 유니트(Control Unit)
    - 명령어를 해석하고 그를 실행하기 위한 제어 신호를 순차적으로 발생
    - 나머지 장치를 control하여 signal를 보내는 장치
  - CPU 내부 버스(internal bus)
    - 데이터 이ㅣ동을 위한 데이터 선과 제어 신호 선들로 구성된 내부 버스
    - 외부의 시스템 버스와는 직접 연결되지 않음. 반드시 버퍼 레지스터들 혹은 시스템 버스 인터페이스 회로를 통해 시스템 버스와 접속함
- 명령어 실행
  - 명령어 사이클(instruction cycle)
    - cpu가 한 개의 명령어를 실행하는 데 필요한 전체 처리 과정.
    - cpu가 프로그램 실행 시작한 순간부터 전원을 끄거나 회복 불가능한 오류가 발생해 중단될 때까지 반복
    - 부사이클(subcycle) : cpu마다 조금씩 다르게 설정됨.(기본 2단계, 8단계 까지 다양함)
      - 인출 사이클 : cpu가 기억장치(메모리)로부터 명령어를 읽어오는 단계
      - 실행 사이클 : 명령어를 실행하는 단계
  - 명령어 실행에 필요한 cpu 내부 레지스터(특수 레지스터)
    - PC : 프로그램 카운터
      - 다음에 인출할 명령어의 주소를 가진 레지스터
      - 각 명령어가 인출된 후에는 자동적으로 일정 크기(한 명령어 길이) 만큼 증가, 즉 명령어 크기가 4면 4만큼 증가. 대체로 4byte 크기
      - 분기(branch) 명령어가 실행되는 경우 분기 목적지 주소로 갱신
    - AC : 누산기(Accumulator)
      - 데이터를 일시적으로 저장하는 레지스터, ALU의 결과로 저장하고 입력으로 사용될 수 있다.
      - 특수, 일반용으로도 사용될 수 있다.
      - 레지스터의 크기는 cpu가 한 번에 처리 가능한 데이터 비트 수(단어 길이), 32비트 컴퓨터는 32비트 레지스터를 가진다.
    - IR : 명령어 레지스터(Instruction Register)
      - 가장 최근에 인출된 명령어 코드가 저장된 레지스터
    - MAR : 기억장치 주소 레지스터(Memory Address Register)
      - pc에 저장된 명령어 주소가 시스템 주소 버스로 출력되기 전에 일시적으로 저장되는 주소 레지스터
      - 즉, 명령어 인출단계에서 PC라는 레지스터에서 주소를 통해 Memory의 명령어를 가져올 때, MAR을 거쳐서 나가게 된다는 것. 혹은 IR에 저장된 주소를 가지고 AC에 접근하기도 함.
    - MBR : 기억장치 버퍼 레지스터(Memory Buffer Register)
      - 기억장치에 쓰여질 데이터 혹은 기억장치로부터 읽혀진 데이터를 일시적으로 저장하는 버퍼 레지스터
      - Memory의 주소에서 읽은 데이터를 다시 cpu로 전달할 때 반드시 이를 거친다는 것이다.
    - ![Alt text](/images/5-0.png)
- 인출 사이클
  - 인출 사이클의 마이크로 연산
    - ![Alt text](/images/5-1.png)
    - t0 : PC에 명령어의 주소가 저장되어 있으니, 그 주소가 MAR을 거쳐서 시스템버스를 거쳐 Memory로 가게 된다.
    - t1 : 메모리에서 그 주소가 지정하는 위치에서부터 읽힌 명령어가 데이터 버스를 동해 MBR로 적재된다. PC는 1을 더한다(숫자 1이 아니고 한 명령어의 길이라고 보는 것).
    - t2 : MBR에 있는 명령어 코드가 명령어 레지스터인 IR로 이동한다.
    - 제어장치에서 신호가 나오면 이러한 과정을 한 개씩 처리하게 되는 것이다.
    - 1GHz는 1초에 10억개의 클럭이 발생하는 것임. 1 클럭은 1나노초. 그래서 3개 주기라고 한다면 *3해서 3나노초 소요
- 실행 사이클
  - cpu는 실행 사이클 동안에 명령어 코드를 해독하고 그 결과에 따라 필요한 연산을 수행함
  - 연산의 종류(아래 이외에도 매우 많음)
    - 데이터 이동
    - 데이터 처리
    - 데이터 저장
    - 프로그램 제어 : 프로그램 실행 순서를 결정
  - 실행 사이클의 마이크로 연산은 명령어에 따라 다를 것.
- 명령어 형식의 구성
  - 연산 코드 (operation code)
    - cpu가 수행할 연산 지정
  - 오퍼랜드(operand)
    - 명령어 실행에 필요한 데이터가 저장된 주소(addr). 주소 말고 다른 것도 가능
  - LOAD addr 명령어
    - 기억장치에 저장되어 있는 데이터를 cpu 내부 레지스터인 AC로 이동하는 명령어
    - ![Alt text](/images/5-2.png)
    - 가장 최근에 pc로부터 인출된 명령어의 주소는 IR에 저장되어 있다. 이를 통해 Memory에서 데이터를 인출하는 것이다.
    - 오퍼랜드에 주소가 들어있고, 연산 코드에 Load가 들어 있다. 제어장치에 해당 명령을 내리게 되고 그 과정이 수행됨
    - t0 : 오퍼랜드 주소만 가지고 IR에서 MAR통해 Memory로 간다.
    - t1 : 메모리에서 해당 MAR의 주소값을 통해 데이터를 찾아 MBR로 적재한다.
    - t2 : 데이터 이기 때문에 주소가 아니니까 IR이 아닌 AC로 이동한다. 데이터 적재의 다른 레지스터가 있다면 거기로 이동할 수도 있다.
  - STR addr 명령어(저장하는 명령어)
    - AC 레지스터의 내용을 기억장치에 저장하는 명령어
    - ![Alt text](/images/5-3.png)
  - ADD addr 명령어(더하라는 것)
    - 기억장치에 저장된 데이터를 AC의 내용과 더하고, 그 결과를 다시 AC에 저장하는 명령어
    - ![Alt text](/images/5-4.png)
    - 당연히 연산을 위해 중간에 ALU를 거친다.
  - JUMP addr 명령어(순서대로 실행하다 무언가를 건너뜀)
    - 오퍼랜드가 가리키는 위치의 명령어로 실행 순서를 변경하는 분기 명령어
    - ![Alt text](/images/5-5.png)
    - 순서대로 되지 않고 IR에 저장된 데이터 주소로 PC의 값을 변경하는 것이다.
    - 루프, 서브루틴 같은 것들이 모두 그러하다.
- 인터럽트 사이클
  - 인터럽트 : 프로그램 실행 중에 CPU의 현재 처리 순서를 중단하고 다른 동작을 수행토록 하는 시스템 동작
  - 외부로부터 인터럽트 요구가 오면
    - CPU는 원래의 프로그램 수행 중단
    - 요구된 인터럽트를 위한 서비스 프로그램을 먼저 수행
    - 끝나면 원래의 프로그램으로 복귀
  - 인터럽트 서비스 루틴(ISR) : 인터럽트를 처리하기 위하여 수행하는 프로그램 루틴
  - 인터럽트 처리 과정
    - cpu는 인터럽트가 들어오면
      - 어떤 장치가 인터럽트를 요구했는지 확인(IRQ). 해당 ISR 호출
      - 서비스가 종료된 다음 중단되었던 원래 프로그램의 수행 계속
      - 예) 프린트를 하다가 용지 부족하면 용지 부족 관련 서비스 루틴이 실행됨. 용지를 채우고 신호를 보내면 원래 프로그램으로 복귀
    - cpu 인터럽트 처리의 세부 동작
      - 현재의 명령어 실행을 끝내고 다음에 실행할 명령어의 주소(PC의 주소들)를 스택에 저장 -> 일반적으로 스택은 주기억장치의 특정 부분
      - ISR을 호출하기 위해 그 루틴의 시작 주소를 pc에 적재, 이 때 시작 주소는 인터럽트를 요구한 장치로부터 전송되거나 미리 정해진 값으로 결정
  - ![Alt text](/images/5-6.png)
  - ![Alt text](/images/5-7.png)
  - 사실은 AC와 같은 레지스터의 내용도 스택에 저장하게 되어 있다.(block 단위임). 왜냐하면 다시 복귀했을 때 사용할 수도 있으니까
  - 다중 인터럽트
    - 인터럽트 서비스 루틴을 수행하는 동안에 다른 인터럽트 발생
    - 처리방법
      - cpu가 인터럽트 서비스 루틴을 처리하는 도중에는 새로운 인터럽트 요구가 와도 해당 인터럽트 사이클을 수행하지 않도록 방지한다.(이 경우는 인터럽트 처리하지 않음)
        - 인터럽트 플래그 0 = 인터럽트 불가능
        - 시스템 운영상 중요 프로그램이나 도중에 중단할 수 없는 데이터 입출력 동작 등을 위한 인터럽트를 처리할 시 사용
      - 처리가능하다면, 인터럽트의 우선 순위를 정하고, 우선 순위가 낮은 인터럽트가 처리되고 있는 동안에 우선순위가 더 높은 인터럽트가 들어오면 현재의 인터럽트 서비스 루틴의 수행을 중단하고 새로운 인터럽트 처리
- 간접사이클(포인터 이용)
  - 명령어에 포함되어 있는 주소를 이용해 그 명령어 실행에 필요한 데이터의 주소를 인출하는 사이클
    - 간접 주소지정 방식. 즉, 직접 가서 데이터를 가져오지 않고 한 번 더 혹은 여러 번 가서 데이터의 주소 인출
  - 인출 사이클과 실행 사이클 사이에 위치
  - ![Alt text](/images/5-8.png)
- 명령어 파이프라이닝(instruction pipelining)
  - cpu의 프로그램 처리 속도를 높이기 위해 cpu 내부 하드웨어를 여러 단계로 나누어 동시에 처리하는 기술
  - 클럭을 향상시키는 것은 한계가 있어서 다른 방법을 사용하는 것. 
  - 2-단계 명령어 파이프라인
    - 명령어를 실행하는 하드웨어를 인출 단계와 실행 단계라는 두 개의 독립적인 파이프라인 모듈로 분리
    - 두 단계들에 동일한 클록을 가해 동작 시간을 일치시킴
      - 첫 번째 클록 주기에서 인출 단계가 첫 번째 명령어를 인출
      - 두 번째 클록 주기에서 인출된 첫 번쨰 명령어가 실행 단계로 보내져서 실행되며, 그와 동시에 인출 단계는 두 번째 명령어를 인출
    - ![Alt text](/images/5-9.png)
    - 2단계 파이프라인을 이용시 명령어 처리 속도가 두 배 향상(일반적으로 단계 수만큼의 속도 향상)
    - 문제점 : 두 단계의 처리 시간이 동일하지 않을 시, 두 배의 속도 향상을 얻지 못함.
      - 해결책 : 파이프라인 단계의 수를 증가시켜 각 단계의 처리 시간을 같도록
  - 4단계 명령어 파이프라인(보통 4단계 이상으로 함 ㅎㅎ)
    - 단계
      - 명령어 인출(IF) 단계 : 다음 명령어를 기억장치로부터 인출
      - 명령어 해독(ID) 단계 : 해독기를 이용해 명령어를 해석
      - 오퍼랜드 인출(OF) 단계 : 기억장치로부터 오퍼랜드 인출
      - 실행(EX) 단계 : 지정된 연산 수행
    - ![Alt text](/images/5-10.png)
    - 실행 시간
      - 파이프라인 단계 수 : k
      - 명령어 수 : N
      - 파이프라인마다 한 클럭 주기씩 걸린다고 가정시 T = k + (N-1)
        - 즉, 첫 번째에 k주기가 걸리고, 나머지 N-1개는 한 주기씩 소요
      - 파이프 라인이 안되면? : T = k * N
  - 파이프라인의 효율 저하 요인
    - 모든 명령어가 파이프단계를 모두 거치지 않음. 어떤거는 오퍼랜드 인출 필요가 없다.
    - 그러나 위의 내용은 하드웨어로 해결 가능
    - 파이프라인의 클록은 처리 시간이 가장 오래 걸리는 단계를 결정됨.
    - IF, OF단계가 동시에 기억장치를 엑세스시 기억장치 충돌이 일어나면 지연 발생
    - 조건 분기 명령어가 실행시 미리 인출하여 처리하던 명령어가 무효화됨
