슈퍼스칼라 구조

- 구조
  - 프로세서 내에 파이프라인 된 기능 유니트(functional unit: ALU 또는 명령어 실행 유니트)를 여러 개 포함시켜서, 매 사이클마다 한 개 이상의 명령어들이 동시에 처리될 수 있도록 하는 구조
  - ![Alt text](/images/23-0.png)
  - ![Alt text](/images/23-1.png)
    - 파이프가 여러 개여서 여러 기능 유니트가 있는 구조
- 문제점
  - Flow dependency(data dependency, RW)
    - true dependency라고도 불림
    - 앞의 명령어의 결과가 뒤의 명령어에 영향을 끼치는 경우
    - 만약, A=3, B=A, C=B라는 3개의 명령어가 있다면 C=B는 B=A에 의해 의존성을 가진다. A의 결과를 B에 저장하게 되기 때문에 C는 다시 B를 받아서 값이 변화되기 때문에 이전 명령어에게 의존하게 되는 것이다.
    - 현실적으로 순서대로라면 이를 해결할 수 없다. 컴파일러가 애초에 이를 의존성이 없도록 배치할 수도 있는데 매우 어려운 방식이다.
  - Anti-dependency(WW)
    - 어떤 명령어가 필요한데 그것이 나중에 업데이트 되는 경우
    - 예를 들어서, 1.B=3, 2.A=B+1, 3.B=7의 3개의 경우에 3번째는 2번째에 있어서 안티 의존성이 생긴다. 즉, 2가 진행되기 전에 3이 먼저 실행되면 안되는 것이다.
    - 이를 name dependency라고도 불린다. 
    - 이럴 경우에는 3의 B와 2의 B가 이름이 달라도 되기 때문에 다른 이름을 써서 의존성을 제거하는 방식을 사용한다(register renaming)
  - Output dependency(WR)
    - 1. A=2*X, 2. B=A/3, 3. A=9 * Y라고 한다면, 2번은 1번의 결과를 가져가야 하는데, 3번이 만약 먼저 실행되면 출력부분에서 의존성이 발생할 수 있다.
    - 이 경우에도 또한 이름을 바꾸면 문제가 없다.
  - 의존성 또는 storage conflicts
    - true dependency는 실제 데이터의 흐름에 가장 큰 영향을 미친다. 이 때는 pipleline이 stall(중지)될 수밖에 없다.
    - 이외의 데이터 dependency(output, anti)같은 경우에는 단순히 메모리 충돌과 관련된 의존성이기에 새로운 레지스터를 구성해서 의존성을 쉽게 해결할 수 있다.
  - Register renaming
    - 만약 R3에서 이러한 문제가 발생했다면, 이 이름을 R3a와 같은 식으로 레지스터 이름을 바꿔서 사용하면 문제가 간단히 해결되는 것.
    - ![Alt text](/images/23-2.png)
      - 버퍼를 통해서 이름을 바꾸어 명령어가 동시에 실행될 수 있도록 해결
  - Structural hazards
    - 구조적 문제임
    - 만약, 파이프가 두 개가 동시에 실행된다면, 같은 연산을 실행해야 한다면 ALU가 2개가 필요할 것이다. ALU가 한 개라면 경합문제가 발생할 수 있을 것이다.
    - 즉, ALU가 동시에 사용되거나 branch 명령어가 실행될 경우 등에서 이러한 문제가 발생할 수 있다.
    - 또한 명령어를 읽기/쓰기 할 때 동시에 메모리에 접근하는 경우도 그러하다.
      - 이런 경우를 해결하기 위해 캐시 메모리를 분리하거나, harvard architecture등을 사용하기도 함.
      - 이는 메모리를 구분하는 것. 데이터 메모리와 명령어 메모리로 구분하게 되면 해결가능
  - Branch (control) hazards
    - 브랜치는 어느 조건에 의해 Jump하게 되는 것인데, 이 때, JUMP가 결정되기 이전에 실행되고 있는 모든 프로그램이 폐기처분 되어야 한다는 문제가 있다.(만약 JUMP가 된다면)
    - 이 경우에는 순차적인 명령어들이 폐기되는 문제가 되어서 미리 이러한 경우를 예측해서 실행해야 한다. 해결하기 어려운 문제이다.
    - 예를 들어, loop와 같은 경우에는 loop buffer를 이용해 이를 해결한다.