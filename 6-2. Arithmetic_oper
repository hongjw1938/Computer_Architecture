### 컴퓨터의 산술과 논리 연산
- 정수의 산술 연산
  - A <- A-bar + 1 : 보수화(2의 보수 변환
  - 덧셈
    - 2의 보수로 표현된 수의 덧셈 방법 : 두 수를 더하고, 만약 올림수 발생시 버림
    - ![Alt text](/images/6-2-0.png)
    - 병렬 가산기 : 덧셈 수행하는 하드웨어 모듈
      - 비트 수만큼의 전가산기들로 구성됨.
      - 덧셈 연산 결과에 따라 해당 조건 플래그를 세트
        - C 플래그 : 올림수
        - S 플래그 : 부호
        - Z 플래그 : 0 - 모두 0일 때, 1이 세팅됨.
        - V 플래그 : 오버플로우(overflow)
    - 오버플로우 플래그
      - 바로 직전과 carry가 XOR 연산을 해서 들어가게 됨.
    - 덧셈 오버플로우 
      - 덧셈 결과가 그 범위를 초과하여 결과값이 다르게 되는 상태.
      - 검출 방법 : 두 올림수들 간의 XOR연산
      - ![Alt text](/images/6-2-1.png)
      - 즉, 최종 캐리 0과 올라간 캐리 1이 서로 다르기 때문에 오버플로우인 것이다.
  - 뺄셈
    - 덧셈을 이용해서 수행한다.
    - A : 피감수(minuend) , B : 감수(subtrahend) : A - ( + B) = A + (-B), A-(-B) = A + B
    - 즉, 2의 보수를 취해서 덧셈연산을 하게 되면 값이 나오는 것이다.
    - 이 연산을 위해서 보수기가 하드웨어에 포함되어 있다. 
    - 뺄셈 오버플로우
      - 검출 방법은 덧셈과 동일하다. 캐리의 XOR 연산
- 부동소수점 수의 표현
  - 부동소수점(floating-point) : 말 그대로 point가 떠 다니는 듯. 소수점 위치가 계속 변한다는 것을 의미한다. -> 수 표현 범위 확대
  - 일반적인 형태 : N = (-1)^s * M * B^E(S : 부호, M : 가수, B : 기수, E : 지수), 보통 B는 2를 나타냄, S가 0이면 양수, 1이면 음수
  - 10진 부동소수점 수 : 274,000,000,000,000 -> 2.74 * 10^14
  - 2진 부동소수점 수 : 기수 B = 2
    - 단일 정밀도 : 32비트
      - 부호 1비트, 지수 8비트, 가수 23비트
      - 지수 필드의 비투 수 증가 : 표현 가능한 수의 범위 확장
      - 가수 필드 비트 수 증가 : 정밀도 증가
      - 고정 소수점방식인 경우에는 범위가 고정됨. 2의 -31승부터 31승까지. - 표현 범위가 많이 감소함..
    - 복수 정밀도 : 64비트
  - 정규화된 표현
    - 수에 대한 표현을 한 가지로 통일하는 방법 : +/- 0.1bbb...b * 2^E
    - 예) 0.1101 * 2^5
      - 부호 비트 : 0, 지수 : 00000101 - 5, 가수 : 1101 0000 0000 0000 0000 000
      - 소수점 아래 첫 번째 비트는 항상 1이므로 저장할 필요 없다.
  - 바이어스된 지수
    - 지수를 바이어스된 수로 표현.(지수에 대한 부호 표시)
    - 목적
      - 0에 대한 표현에서 모든 비트가 0이 되게 하여, 0-검사가 용이하도록 하기 위함
      - 0검사가 정수에서와 같은 방법으로 가능
    - 8-비트 바이어스된 지수값들
      - ![Alt text](/images/6-2-2.png)
      - 01111111이 바이어스 = 127이면 지수가 0이다. 이보다 작으면 음수, 크면 양수로 표현.
      - 바이어스가 128이면 10000000이 0이 되는 방식. 이와 같이 사용함.
    - 바이어스가 128이라면 N = -13.625에 대한 표현은
      - 2진수로 바꾸면 1101.101이 된다.
      - 부호는 1이고,  1101.101 = 0.1101101 * 2^4이므로 지수는 4라서 00000100이 되고 128을 더하면 된다. 그래서 10000100이 된다.
      - 가수는 101101000000000000000~ 소수점 우측의 첫 1은 제외하고 사용한다.
    - ![Alt text](/images/6-2-3.png)
    - ![Alt text](/images/6-2-4.png)
    - 오버플로우 쪽은  -INF와 INF가 된다.
  - 부동소수점 수 표현 표준방식(중요)
    - IEEE 754 방식 : 미국전기전자공학회에서 정의한 표준
      - 방법 : N = (-1)^S 2^(E-127) (1.M) - C언어의 float
      - 가수 : 부호화-크기 표현 사용
      - 지수 필드 : 바이어스 127사용
      - 1.M * 2^E 의 형태이며, 소수점 아래의 M 부분만 가수 필드에 저장(소수점 왼쪽의 저장되지 않는 1은 hidden bit : 히든비트는 1. 여기서 1을 의미)
      - 64-비트 복수-정밀도 부동소수점 형식일 경우 :  N = (-1)^S 2^(E-1023) (1.M) - C언어의 double
        - 이 때는 부호 1비트, 지수 11비트, 가수 52비트에 바이어스는 1023
      - 예시) -13.625(10) 은 2진수로 1101.101(2)인데 이를 1.101101 * 2^3 이 된다.
        - 부호는 1이고
        - 지수는 E = 00000011 + 01111111 = 10000010(바이어스 127을 더함)
        - 가수는 맨 왼쪽의 1만 빼고 나머지 표시
      - 예시) 0.3(10)을 2진수로 하면 0.010011001... 로 반복하는 무한이 된다. 그러면 이에 따라 소수점이 이동하여 1.001100110011...(2)이렇게 무한히 반복 소수점이 두칸 움직였으므로 2^-2를 곱하면 정규화 된 것.
        - 부호는 0이고, 지수는 10 이므로 여기서 127을 뺀다(0보다 작기 때문). 나머지는 가수에 표시.
      - ![Alt text](/images/6-2-5.png)
- 부동소수점 산술 연산
  - 덧셈과 뺄셈
    - 지수들이 일치되도록 조정(지수가 큰 쪽으로)
    - 가수간의 연산 수행
    - 결과를 정규화
    - ![Alt text](/images/6-2-6.png)
    - ![Alt text](/images/6-2-7.png)
    - 표준 정규화는 1.M이다. 위의 결과는 일반론.
  - 부동소수점 산술의 파이프라이닝
    - 연산 과정을 독립적 단계로 분리가능
    - 단계 수만큼의 속도 향상
    - 대규모의 부동소수점 계산을 처리하는 거의 모든 슈퍼컴퓨터들에서 채택
    - 각 단계는 지수조정, 가수 연산, 정규화
    - 특히 배열같은 경우 이를 사용하면 속도가 빨라진다.
  - 곱셈/나눗셈
    - 곱셈
      - 가수를 곱한다.
      - 지수를 더한다
      - 결과값 정규화
    - 나눗셈
      - 가수를 나눈다
      - 피제수의 지수에서 제수의 지수를 뺀다
      - 결과값 정규화
  - 문제점
    - 지수 오버플로우
      - 양의 지수값이 최대 지수값 초과 : 수가 너무 커서 표현 불가. +INF 또는 -INF로 세트
    - 지수 언더플로우
      - 음의 지수값이 최대 지수값 초과 : 수가 너무 작아서 표현될 수 없으므로 0으로 세트
    - 가수 언더플로우
      - 가수의 소수점 위치 조정 과정에서 비트들이 가수의 우측 편으로 넘침 : 반올림 사용
    - 가수 오버플로우
      - 같은 부호를 가진 두 가수들을 덧셈시 올림수 발생 : 재조정 과정을 통해 정규화
