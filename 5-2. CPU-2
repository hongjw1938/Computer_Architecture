### CPU 기능2
- 명령어 파이프라이닝
  - 해저드: Hazard
    - 중앙처리장치의 마이크로 구조의 명령어 파이프라인에서 발생하는 문제. 잠재적으로 계산의 결과에 오류가 발생
    - 종류
      - 데이터 해저드 : 실행순서에 따른 데이터 충돌
      - 구조적 해저드 : 하드웨어 설계상의 문제
      - 제어 해저드 또는 분기 해저드 : 루프, 조건에 따라 프로그램 분기가 발생하는데 이에 따른 문제
    - 처리방법
      - 파이프라인 스톨(멈추는 방법 - 성능저하)
      - 파이프라인 버블링(중간에 기능 안하는 명령어 끼워넣음)
      - 레지스터 포워딩(레지스터에서 나온 결과를 미리 저장) 등
    - 비 순서적 실행(out-of-order)
      - 스코어보딩 방법과 토마술로 알고리즘
  - 데이터 해저드
    - 파이프라인의 서로 다른 단계에서 수정이 필요한 데이터들 끼리 의존성이 존재시 발생. 잠재적 데이터 해저드를 무시하면 경쟁조건이 발생(race condition, race hazards)
      - 하나는 받고 하나는 출력하려 한다든지해서 아무런 결과가 나오지 않는 경우 등
    - 발생 가능 상황
      - read after write(RAW) : 참 의존성(a true dependency), 가장 문제가 됨
      - write after read(WAR)
      - write after write(WAW)
    - RAW : 참 종속(true dependency)
      - 두 개의 명령 i1과 i2가 있을 때, 프로그램의 순서상 i1이 i2보다 앞에 있다고 가정
      - i1이 어떤 값을 저장하기 전에 i2가 그 값을 읽으려고 시도
      - 앞 명령의 연산이 끝나지 않았거나 값을 가져오기 전에 뒤의 명령에서 그 데이터를 사용하려고 할 경우 발생.
      - 즉, 이전 명령이 파이프라인을 통해 처리 되지 않아서 이후 명령이 그 값을 사용 못하는 경우
      - 즉, i1의 완료에 i2가 의존하게 된다. 데이터 의존성
      - 원천적으로는 해결 불가. 그래서 파이프라인에 NOP(no operation)을 끼워 넣는 방법을 사용한다. --> bubble을 끼우는 것, 혹은 스톨
      - 혹은 명령어 재배치(미리 의존성 체크해서 컴파일러가 할 일)
    - WAR
      - i1이 읽어가기 전에 i2가 목적지에 저장하려고 함.
      - 동시 실행으로 인해 발생하는 문제
      - Register renaming : 레지스터 이름을 변경, 하드웨어적인 방법이나 컴파일러가 바꿔줌, 여분의 레지스터 필요. 즉, 레지스터가 많이 필요
    - WAW
      - i1이 저장하기 이전에 i2가 저장하려는 경우
      - 동시 실행환경에서 발생 가능
      - i1의 실행이 완료시까지 i2는 데이터 저장을 대기하고 있어야함.
      - Register renaming 
  - 구조적 해저드
    - 동시에 두 개 이상의 명령이 프로세서의 하드웨어 중 한 부분을 사용하려 할 경우 발생.
    - 일반적인 예는 단일 메모리 장치에 대해 하나의 명령을 인출하려고 시도하고, 다른 하나는 데이터를 인출(또는 저장 )하려고 하는 두 가지 단계가 동시에 발생하는 경우이다.
    - 해결 방법
      - 명령어 인출과 데이터 인출이 동시에 발생하는 경우
        - 메모리 장치 분리하거나 분리 캐시 사용
          - 현대의 프로세서는 L1 cache가 분리되어 있음, 명령어 캐시와 데이터 캐시
        - 메모리 자체 분리 : 하버드 아키텍쳐(cf. 폰 노이만 구조), 명령어와 데이터 메모리 분리함.
        - 파이프라인에 버블을 끼움
      - cpu내의 장치에서 충돌이 생기는 경우
        - 추가적인 장치 여러 개 둠
          - ALU를 2~3대 두는 방법 등
  - 제어 해저드
    - 분기가 발생시 일어남. (if, for, while, break.. 같은 분기문)
    - 많은 구조에서 프로세서는 파이프라인에 새로운 명령이 들어가면 분기문 결과를 알아야 하는데 그러지 못함..
    - 대체로 4단계에서 분기문은 EX단계에서 발생함. 이래버리면 jump를 못하고 파이프라인에서는 그 다음도 미리 진행을 해버리기 때문에 다음 사이클들이 손해를 보게 된다.
    - 해결 법
      - 분기 예측
        - 분기가 일어날 것인지 예측함. 그에 따라 명령어를 인출하는 확률적 방법
        - 분기 역사 표(branch history table)이용해 분기 결과 참조
      - 분기 목적지 선인출(prefetch branch target)
        - 조건 분기가 인식되면, 분기 명령어의 다음 명령어뿐만 아니라 분기의 목적지 명령어도 함께 인출하는 방법
      - 루프 버퍼
        - 가장 최근 인출된 n개의 명령어를 고속 기억장치인 루프 버퍼에 순서대로 저장하는 방법
      - 지연 분기
        - 분기 명령어의 위치를 재배치하여 파이프라인의 성능 개선
        - 매우 어려운 방법. 컴파일러가 사용
- 상태 레지스터(status register) 혹은 Flag register, Program status word
  - 조건분기 명령어가 사용할 조건 플래그들 저장
    - 부호(S) 플래그 : 직전에 수행된 산술연산 결과값의 부호 비트를 저장
    - 영(Z) 플래그 : 연산 결과값이 0이면 1
    - 올림수(C) 플래그 : 덧셈이나 뺄셈에서 캐리나 빌림수(borrow)가 발생시 1로 세트
    - 동등 플래그 : 두 수를 비교한 결과가 같으면 1로 세트
    - 오버플로우 플래그 : 산술 연산 과정에서 오버플로우가 발생시 1로 세트
    - 인터럽트 플래그 : 인터럽트 가능시 0, 불가능시 1로 세트
    - 슈퍼바이저 플래그 : cpu의 실행 모드가 슈퍼바이저 모드면 1로, 사용자 모드면 0으로 세트
    - 등등 더 많다.
- 슈퍼스칼라(Superscalar)
  - cpu의 처리 속도를 더욱 높이기 위해 내부에 두 개 혹은 그 이상의 명령어 파이프라인들을 포함시킨 구조
  - 매 클록 주기마다 각 명령어 파이프라인이 별도의 명령어를 인출하여 동시에 실행 가능하기에, 이론적으로는 프로그램 처리 속도가 파이프라인 수만큼 향상 가능
  - 파이프라인 수 = m : m-way 슈퍼스칼라
    - ![Alt text](/images/5-2-0.png)
    - 이는 2-way임. 한번에 2개씩 실행함
  - 속도 향상(speedUp, sp)
    - 단일 파이프라인 : T(1) = k + N - 1
    - m-way 슈퍼스칼라  : T(m) = k + (N-m) / m
    - 속도 향상 : Sp = T(1)/T(m)
    - 만약 N -> infinite 라면, Sp는 m배 만큼 빨라지는 것
  - 속도 저하 요인(해저드 등의 문제)
    - 동시 실행 가능 명령어 수 < m
    - 해결책
      - 명령어 실행 순서 재배치 - 의존성 제거
      - 하드웨어 추가 설치 - 기억장치 및 레지스터에 대한 경합 감소
  - 듀얼코어 및 멀티코어
    - CPU 코어 : 명령어 실행에 필요한 cpu 내부의 핵심 하드웨어(슈퍼 스칼라) 모듈
    - 멀티코어 프로세서 : 여러 개의 cpu 코어들을 하나의 칩에 포함시킨 프로세서
      - 듀얼 코어 : 두 개의 cpu 코어 포함
      - 쿼드 코어 : 4 개의 cpu 코어 포함
    - 칩-레벨 다중프로세서 혹은 단일칩 다중프로세서 라고도 부른다.
    - 각 코어는 별도의 H/W 모듈로 이루어지며 시스템버스와 캐시만 공유
      - 프로그램 실행에 있어서 각 코어는 더 높은 독립성 : 멀티-태스킹, 멀티-스레딩
- 명령어 세트(instruction set)
  - 어떤 cpu를 위하여 정의되어 있는 명령어들의 집합
  - 명령어 세트 설계를 위해 결정되어야 할 사항들
    - 연산 종류(operation repertoire) : cpu가 수행할 연산들의 수와 종류 및 복잡도
    - 데이터 형태(data type) : 연산을 수행할 데이터들의 형태, 데이터의 길이(비트 수), 수의 표현 방식 등
    - 명령어 형식(instruction format) : 명령어의 길이, 오퍼랜드 필드들의 수와 길이 등
    - 주소지정 방식(addressing mode) : 오퍼랜드의 주소를 지정하는 방식
  - 연산의 종류
    - 데이터 전송 : 레지스터 - 레지스터 - 기억장치 - 기억장치 간 데이터 이동
    - 산술 연산, 논리 연산, 입출력, 프로그램 제어(분기, 서브루틴 등)
    - 서브루틴 호출을 위한 명령어
      - 서브루틴은 프로그램 내에 반복호출되는 프로세스. 
      - CALL 명령어 : 현재의 pc 내용을 스택에 저장 후 서브루틴의 시작 주소로 분기하는 명령어
      - RET 명령어 : CPU가 원래 실행하던 프로그램으로 복귀(return)
      - ![Alt text](/images/5-2-1.png)
      - ![Alt text](/images/5-2-2.png)
